# -*- coding: utf-8 -*-
"""agents.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gD_4NTPXwhkTspoJz7KL4vuzfBzStsn-
"""

from typing import Dict, List, Any, TypedDict

from config import DEFECT_CATEGORIES

from utils import invoke_with_retry

from fetchers import fetch_buggy_code

class AgentState(TypedDict):
    program_name: str
    buggy_code: str
    defect_category: str
    code_understanding: str
    fixed_code: str
    fix_explanation: str
    messages: List[Dict[str, Any]]
    current_step: str

print("State management class defined")

def agent1_fetch_and_categorize(state: AgentState) -> AgentState:
    """Agent 1: Fetch buggy code and categorize defect"""

    print(f"Agent 1: Fetching and categorizing {state['program_name']}...")

    fetch_result = fetch_buggy_code.invoke(state["program_name"])

    if not fetch_result.get("success", False):
        raise Exception(fetch_result.get("error", "Unknown error during fetch"))

    state["buggy_code"] = fetch_result["buggy_code"]
    state["test_cases"] = fetch_result["test_cases"]

    categorization_prompt = f"""You are a defect clssifying agent. Remembering the 14 defects from {DEFECT_CATEGORIES},
     I need you to very carefully assess the code and return the defect category in the following:


**Code:**
{state['buggy_code']}
"""

    response = invoke_with_retry(gemini_llm, categorization_prompt)

    defect_category = None
    for category in DEFECT_CATEGORIES:
        if category in response.content.lower():
            defect_category = category
            break

    if not defect_category:
        defect_category = "other"

    state["defect_category"] = defect_category
    return state

def agent2_understand_code(state: AgentState) -> AgentState:
    print(f"Agent 2: Understanding code structure...")

    prompt = f"""You are an assisstant used only for understanding the context of the given code, what it is meant to do by using the defect category
    analyzed earlier. You are meant to understand the purpose of the code and the structure. Make use of comments in the given code:
**Program Name:** {state['program_name']}
**Defect Category:** {state['defect_category']}

**Buggy Code:**
{state['buggy_code']}
"""
    try:
        response = invoke_with_retry(gemini_llm, prompt)

        state['code_understanding'] = response.content
        state['understanding_prompt'] = prompt
    except Exception as e:
        state['code_understanding'] = f"Error in understanding: {str(e)}"

    return state

def agent3_fix_code(state: AgentState) -> AgentState:
    """Agent 3: Fix code and provide explanation using Mistral"""
    print(f"Agent 3: Fixing the code...")

    prompt = f"""You are a code-fixing assisstant. I will give you examples of single-line fixes for the reocurring defect categories that I want you to understand to help in fixing the program. But do not solely rely on these as there might be exceptions and the example fixes I will be giving are generalizations.
    1. Defect: Off-by-one
       Example: arr = [10, 20, 30]
                for i in range(len(arr) + 1):
                print(arr[i])
                fix: to iterate through the entire list the code will be fixed by replacing 'len(arr)+1' with len(arr)
    2.Defect: Incorrect Variable
      Example:def bucketsort(arr, k):
                   counts = [0] * k
                   for x in arr:
                      counts[x] += 1
                   sorted_arr = []
                   for i, count in enumerate(arr):
                      sorted_arr.extend([i] * count)

                   return sorted_arr
      Fix:counts tells how many times each number appears. so replaace 'enumerate(arr)' with 'enumerate(counts)'
    3.Defect: Missing Function call
      Example:
      def max_sublist_sum(arr):
            max_ending_here = 0
            max_so_far = 0
            for x in arr:
                  max_ending_here = max_ending_here + x
                  max_so_far = max(max_so_far, max_ending_here)
            return max_so_far
            Fix: max_ending_here = max(0, max_ending_here + x). this function call is missing
     4.Defect: Variable swap
       Example: def gcd(a, b):
                  if b == 0:
                     return a
                  else:
                     return gcd(a % b, b)
              Fix: Here, variables a & b are swapped in the final return statement. The correct order is: return gcd(b, a % b)
      5.Defect: Missing edge case
        Example: def detect_cycle(node):
                   hare = tortoise = node
                   while True:
                   if hare.successor is None:      (this should be: if hare is None or hare.successor is None)
                         return False
                   tortoise = tortoise.successor
                   hare = hare.successor.successor
                   if hare is tortoise:
                         return True
              Fix: You're trying to access .successor.successor without checking if it exists. This can crash if the list ends (i.e., there's no cycle).


**Program Name:** {state['program_name']}
**Defect Category:** {state['defect_category']}
**Code Analysis:** {state['code_understanding']}

**Buggy Code:**
{state['buggy_code']}

Please provide:
- The fixed code
- A brief explanation of the fix
"""

    try:
        response = invoke_with_retry(gemini_llm, prompt)

        parts = response.content.split("Explanation:")
        state['fixed_code'] = parts[0].strip()
        state['fix_explanation'] = parts[1].strip() if len(parts) > 1 else "No explanation provided"
        state['fix_prompt'] = prompt
    except Exception as e:
        state['fixed_code'] = f"Error in fixing: {str(e)}"

    return state